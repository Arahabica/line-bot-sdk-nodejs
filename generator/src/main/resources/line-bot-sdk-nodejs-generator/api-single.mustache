{{>licenseInfo}}

/* tslint:disable:no-unused-locals */
{{#imports}}
import { {{classname}} } from '{{filename}}';
{{/imports}}
import * as Types from "../../types";
import {ensureJSON} from "../../utils";
import {Readable} from "stream";

import { RequestFile } from '../../http';
import HTTPClient from "../../http";
import {AxiosResponse} from "axios";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

{{#operations}}

interface httpClientConfig {
    baseURL?: string;
    channelAccessToken: string;
    // TODO support defaultHeaders?
}


export class {{classname}} {
    private httpClient: HTTPClient;

    constructor(config: httpClientConfig) {
        if (!config.baseURL) {
            config.baseURL = '{{#lambda.endpoint}}{{classname}}{{/lambda.endpoint}}';
        }
        this.httpClient = new HTTPClient({
            defaultHeaders: {
                Authorization: "Bearer " + config.channelAccessToken,
            },
            responseParser: this.parseHTTPResponse.bind(this),
            baseURL: config.baseURL,
        });
    }

    private parseHTTPResponse(response: AxiosResponse) {
        const { LINE_REQUEST_ID_HTTP_HEADER_NAME } = Types;
        let resBody = {
            ...response.data,
        };
        if (response.headers[LINE_REQUEST_ID_HTTP_HEADER_NAME]) {
            resBody[LINE_REQUEST_ID_HTTP_HEADER_NAME] =
                response.headers[LINE_REQUEST_ID_HTTP_HEADER_NAME];
        }
        return resBody;
    }

{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{paramName}} {{description}}
     {{/allParams}}
     */
    public async {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}) : Promise<{{#returnType}}{{{.}}}{{/returnType}}{{^returnType}}Types.MessageAPIResponseBase{{/returnType}}> {
        {{>apiBody/multipart}}
        {{^isMultipart}}

        {{#hasBodyParam}}
        const params = {{bodyParam.paramName}};
        {{/hasBodyParam}}

        {{#hasFormParams}}
        const formParams = {
            {{#formParams}}
            "{{{paramName}}}": {{{paramName}}},
            {{/formParams}}
        };
        {{/hasFormParams}}

        {{#hasQueryParams}}
        const queryParams = {
            {{#queryParams}}
            "{{{paramName}}}": {{{paramName}}},
            {{/queryParams}}
        };
        {{/hasQueryParams}}

        {{#hasHeaderParams}}
        const headers = {
            {{#headerParams}}
            "{{{baseName}}}": {{{paramName}}},
            {{/headerParams}}
        };
        {{/hasHeaderParams}}

        {{#vendorExtensions.isStream}}
        return this.httpClient.{{#lambda.lower}}{{{httpMethod}}}{{/lambda.lower}}Stream("{{{path}}}"{{#lambda.pathReplace}}{{{path}}}{{/lambda.pathReplace}});
        {{/vendorExtensions.isStream}}
        {{^vendorExtensions.isStream}}
        const res = this.httpClient.{{#lambda.lower}}{{{httpMethod}}}{{/lambda.lower}}{{#hasFormParams}}Form{{/hasFormParams}}{{#isMultipart}}Multipart{{/isMultipart}}{{#returnType}}<{{{.}}}>{{/returnType}}(
            "{{{path}}}"{{#lambda.pathReplace}}{{{path}}}{{/lambda.pathReplace}},
            {{#hasBodyParam}}params,{{/hasBodyParam}}
            {{#hasFormParams}}formParams,{{/hasFormParams}}
            {{#hasQueryParams}}queryParams,{{/hasQueryParams}}
            {{#hasHeaderParams}}{ headers },{{/hasHeaderParams}}
        );
        return ensureJSON(res);
        {{/vendorExtensions.isStream}}
        {{/isMultipart}}
    }
{{/operation}}
}
{{/operations}}
